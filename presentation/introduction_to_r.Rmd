---
output:
  revealjs::revealjs_presentation:
    theme: solarized
    highlight: kate
    css: styles.css
    transition: fade
    fig_width: 6
    fig_height: 4
    background_transition: fade
    reveal_options:
      slideNumber: true
---

<h1>R for Data Analysis</h1>

<img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/R_logo.svg/1086px-R_logo.svg.png" height="128" width="128">

<p>Data Science Melbourne - MeDaScIn 2018</p>

<p>Kaushik Lakshman</p>

<p>27 September 2018</p>

# Before we start

## A bit about me

- Kaushik Lakshman, Data Scientist at Betfair 
- R user since ~2013 & massive R fan since day 1
- Hoping to infect you with the same passion!
- No such thing as a stupid question. Interrupt me whenever you have any question
- Everyone is here to learn, don't want anyone feeling left behind :) 
- If you have any questions for later, don't hesitate to email me kaushiklakshman@gmail.com

## What we will cover today 

- An introduction to R & its ecosystem
- Data manipulation/wrangling/munging using dplyr
- Data visualisation using ggplot2
- Rmarkdown and related tools

# Introduction to R

## What is R?

- R is a programming language originally meant for Statistical Computing
- R is now so much more than that
- R is about 25 years old, but has really exploded in the last 5 years
    + Open source and free
    + Incredible dev community (a package for everything)
    + Barrier to entry reduced 

## What can you do in R? 

- Access data from a variety of systems (files, databases, streams)
- Manipulate data (and fix or create data)
- Visualise data
- Model data 
- Report data (Commentary, insights, visualisations, summaries)
- A host of other modern tools
    + Web applications
    + Dashboards
    + Packages
    + Emoji! 
    + Music! 
    + Emails! 
    
## Why is R popular these days? 

- Incredible community around R programming and especially R learning
- R Studio's packages and approach to making analysis easy 
- Help and Documentation 
- Stack overflow & Rstudio community 
- Twitter, Linkedin and social media

## RStudio 

- RStudio is the defacto IDE for R Programming
- Free to download and has very well thought out ease of use features 
    + Code, Console, Environment and Plots/Help on the same window 
    + Auto complete code and auto formatting 
    + Tons of little features to customise according to your liking 
- Has the brightest minds in data science working towards making it easier for other data scientists : Hadley Wickham, Jim Hester, Max Kuhn, Mine Cetinkaya Rundel, Yihui Xie, JJ Alaire

## Basic Syntax

- Mathematical expressions are evaluated as a calculator
```{r}
3+3
```

- You can assign values to variables using the assignment operator `<-` 
```{r}
quick_maths <- 2 + 2 - 1
```

- You can print values by just typing their name of the variable
```{r}
quick_maths
```

## Functions

- Functions take in values and return something 
- Functions are meant to be consistent - Same output for same inputs
- R provides several built in functions

```{r}
sum(1,2,3) ## Adding 1, 2 and 3
sqrt(25) ## Finding square root of 25
```

## Packages

- Inbuilt functions only cover a subset of what one needs to do on a day to day basis
- Packages exist to service this need 
- Packages are maintained in a centralised repository called CRAN
- Packages can also be obtained from other sources
- Packages are installed using the function `install.packages("package_name")`
- Installed packages are loaded to your environment using `library(package_name)`

## Packages 

- Let us try install a very useful package called lubridate
- Lubridate makes it easier to work with dates and times

```{r eval=FALSE}
install.packages("lubridate")
```

```{r message=FALSE}
library(lubridate)

## ymd converts a date in the format YYYY-MM-DD to a date class 
an_example_date <- lubridate::ymd("2018-09-27")
class(an_example_date)

## Adding 5 days to an_example_date
an_example_date + lubridate::days(5)
```

## Basic Data Types

- Everything in R is an object
- Main atomic data types are: charcter, numeric, logical
- Use the class function to find out what data type your object is

```{r}
name <- "Kaushik" ## Character
age <- 29 ## Numeric
```

```{r}
class(name)
class(age)
```

## Basic Data Types

- Collection of these atomic structures are called vectors 
- You can create vectors using the function `c()`

```{r}
cities_in_australia <- c("Melbourne", "Sydney", "Brisbane") ## Vector of Chars
ten_natural_numbers <- c(1:10) ## Vector of numerics
```

```{r}
cities_in_australia
ten_natural_numbers
```

## Data Frames

- Most important data structure in R
- Combination of Vectors 
- Rectangular structure (most data in the world)
- Has Rows and Columns 
- R has some pre loaded data frames to play around with what they look like 

## Data Frames

```{r}
## Creating your own data frame
my_first_data_frame <-
data.frame(city = c("Melbourne","Sydney","Canberra"),
           is_capital = c(FALSE,FALSE,TRUE))
```

```{r}
my_first_data_frame
class(my_first_data_frame)
```

## Data Frames
```{r}
## Pre loaded data frame
data(mtcars)
```

```{r}
## Use the head function to sample a subset of rows
## because most data frames will be too long to print everything
head(mtcars, 3)
```

```{r}
## Use str to inspect the data frame at a glance
str(mtcars)
```

## Getting data in and out of R

- Data can be available in several formats for analysis
    * Files
    * Databases
    * APIs 
- We can use the appropriate packages to load data from any system to R
- Today we will be working only with CSV files, for which we will need the `read_csv` and `write_csv` functions
- These are available through an incredible `tidyverse` package that we will learn about 
```{r eval=FALSE}
install.packages("tidyverse")
```

## Getting data in and out of R 

```{r message=FALSE}
## Loading package tidyverse
library(tidyverse)

## Loading Melbourne Housing Dataset
melbourne_housing <- read_csv("C:/Workspace/r-learning/data/processed/melbourne_housing_market.csv")

glimpse(melbourne_housing)
```

## Getting data in and out of R
```{r eval=FALSE}
## Getting data from Excel to R
data_from_excel <- readxl::read_xlsx(path = "My_file.xlsx",
                                     sheet = "Main Sheet")

## Loading R data structure
data_from_rds <- readRDS(file = "saved_object.RDS")

## Getting data from database
library(odbc)
mysql_connection <- odbc::dbConnect(odbc(), 
                                    Driver = "SQL Server", 
                                    Server = "localhost\\SQLEXPRESS", 
                                    Database = "datawarehouse", 
                                    Trusted_Connection = "True")

my_table_data <- odbc::dbGetQuery(conn = mysql_connection, 
                                  statement = "SELECT * FROM my_table")
```

## Introduction to Tidyverse

- Tidyverse is a collection of packages
- The packages share an underlying design philosophy, grammar of usage and data structures
- The tidy data principles state that 
     * Each variable is a column
     * Each observation is a row 
     * Each type of observational unit forms a table
```{r}
## The dataset we loaded is tidy
head(melbourne_housing, 3)
```

# Data Wrangling with dplyr

## What is dplyr? 

- Data manipulation is really easy and intuitive now because of the `dplyr` package (Contained in `tidyverse`)
- You can use other techniques that base R and other packages provide to do the same stuff but with `dplyr` you don't need to know that anymore!
- `dplyr` is the next evolution of the `plyr` package specifically tuned for data frames and having easy and consistent data wrangling features

## Piping 

- Piping comes from a package called `magrittr`
- Piping allows you to chain consecutive steps of a data manipulation pipeline
- In order of how it is executed as opposed to traditional programming syntax
- Piping is really useful while building dplyr command chains

```{r eval=FALSE}
## Non Piping 
output <- function3(function2(function1(x)))

## Piping 
output <- x %>% 
  function1() %>%
  function2() %>%
  function3
```

## Select

- Select lets you keep only a subset of variables from a data frame

```{r}
melbourne_housing %>%
  select(address, suburb)
```

## Filter 

- Filter lets you keep only a subset of observations that satisy a condition 

```{r}
melbourne_housing %>%
  filter(suburb == "Southbank")
```

## Filter

- You can use any logical operators `>`, `<`, `==`, `!=`
- You can combine multiple logical operators using `&` and `|`

```{r}
melbourne_housing %>%
  filter(suburb == "Mount Waverley" & rooms >= 3 & price <= 1000000)
```

## Arrange

- Arrange lets you sort your data frame by any column you specify
- Defaut order is ascending but we can use `desc()` to sort in descending order

```{r}
melbourne_housing %>%
  filter(suburb == "Mount Waverley" & rooms >= 3 & price <= 1000000) %>%
  arrange(desc(rooms), price)
```

## Rename

- Rename lets you rename your columns to anything you want 

```{r}
melbourne_housing %>%
  select(address, suburb) %>%
  rename(suburb_name = suburb)
```

## Mutate 

- Mutate lets you create new columns or variables 

```{r}
melbourne_housing %>%
  filter(suburb == "Toorak" & price >= 1000000) %>%
  select(address, suburb, price) %>%
  mutate(price_in_millions = price/1000000)
```

## Basic functions wrap up

- Select: Choose columns you want 
- Filter: Choose rows that you want based on conditions 
- Arrange: Sort based on any column(s)
- Rename: Change names of existing columns
- Mutate: Create new columns
- Quick practice: Can you write a dplyr chain to give me all the addresses, suburbs and prices for those properties that were townhouses (type is 't') and sold for more than 1.2 million sorted by descending order of price?

## Basic functions Quick practice - Answer

```{r}
melbourne_housing %>%
  filter(type == 't' & price > 1200000) %>%
  select(address, suburb, price) %>%
  arrange(desc(price))
```

## Group & Summarise

- Data analysis is usually done on rolled up groups
- Collect multiple rows into a set and study summarised statistics for them 
- `dplyr` provides the `group_by` function to let you do this
- Once grouped, we can use the `summarise` function to reduce multiple values to one value

```{r}
melbourne_housing %>%
  group_by(suburb) %>%
  summarise(mean_price = mean(price, na.rm = TRUE))
```

## Summarise 

- Summarise function gives you a bunch of options 
    * `n()` counting rows
    * `n_distinct()` counting unique rows
    * `sum()` summing a variable 
    * `mean()` average of a variable 
    * `median()` median of a variable 
    * and several more 
    
```{r}
## Counting number of houses that sold
## for > 2 million in Brighton and Toorak
melbourne_housing %>%
  filter(suburb == "Toorak" | suburb == "Brighton") %>%
  filter(price > 2000000) %>%
  group_by(suburb) %>%
  summarise(number_of_houses = n())
```

## Another quick practice session

- Out of all the units that were sold 
- give me a list of suburbs 
- that sold units of price > 1m 
- and how many of such units each suburb had 
- Expected answer below 

```{r echo=FALSE}
melbourne_housing %>% 
  filter(type == "u") %>%
  filter(price > 1000000) %>%
  group_by(suburb) %>%
  summarise(number_of_units = n())
```

## Another quick practice session - Solution 

```{r}
melbourne_housing %>% 
  filter(type == "u") %>%
  filter(price > 1000000) %>%
  group_by(suburb) %>%
  summarise(number_of_units = n())
```

## Window functions 

- There are also several window functions that let you work within groups created by group_by
- For example, in the previous example instead of just listing the suburbs, you might want to rank them 
- Examples of window functions available are 
    * `dense_rank()`, `min_rank()`, `row_number()`
    * `cumsum()` , `cummean()`
    * `lead()`, `lag()`
    
```{r}
melbourne_housing %>% 
  filter(type == "u") %>%
  filter(price > 1000000) %>%
  group_by(suburb) %>%
  summarise(number_of_units = n()) %>% 
  mutate(suburb_rank = dense_rank(desc(number_of_units))) %>%
  arrange(suburb_rank)
```

## Another quick practice 

- For each suburb
- what percentage of total property sales 
- are houses, apartments and units 
- Clue: group by suburb and type, find count of properties, then mutate to find percentage
- Expected answer is 

```{r echo=FALSE}
melbourne_housing %>%
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  mutate(percentage_of_properties = number_of_properties/sum(number_of_properties)*100)
```

## Another quick practice - Solution 

```{r}
melbourne_housing %>%
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  mutate(percentage_of_properties = number_of_properties/sum(number_of_properties)*100)
```

## Spread and gather

- Data anlaysis often requires conversion from wide data format to narrow data format

```{r echo=FALSE}
narrow_data_frame <- data.frame(name = c("Alice", "Bob"),
                                subject = c("Maths", "Science", "English"),
                                marks = c(90, 90, 85, 75, 75, 60)) %>%
  arrange(name, subject)

wide_data_frame <- narrow_data_frame %>% spread(subject, marks)

narrow_data_frame
wide_data_frame
```

- The functions that allow for this kind of conversion are `spread()` and `gather()`

## Spread and gather - example

```{r}
## Same percentage of total calculation from couple of slides ago
wide_data_frame <- melbourne_housing %>%
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  mutate(percentage_of_properties = number_of_properties/sum(number_of_properties)*100) %>%
  select(suburb, type, percentage_of_properties) %>%
  spread(type, percentage_of_properties)

wide_data_frame
```

## Spread and gather - example 

```{r}
narrow_data_frame <- wide_data_frame %>%
  gather("type", "percentage_of_properties", h, t, u)

narrow_data_frame
```

## Binding 

- Sometimes we have to bind two data frames together to get a combined data frame
- The functions to do this are `bind_rows` for binding by rows and `bind_cols` for binding by columns

```{r echo=FALSE}
richmond <- melbourne_housing %>%
  filter(suburb == "Richmond") %>% 
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  ungroup()


hawthorn <- melbourne_housing %>%
  filter(suburb == "Hawthorn") %>% 
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  ungroup()
```

```{r}
hawthorn
richmond
```

## Binding 
```{r}
bind_rows(hawthorn, richmond)
```

## Joins 

- Data frames are not always going to be allow you to bind them
- When two different data frames containing two different pieces of information need to be connected we use joins
- Joins come from set theory and there are several types
    * Inner join
    * Left join
    * Right join
    * Full join
    * Semi join
    * Anti join
    
<img src = "http://r4ds.had.co.nz/diagrams/join-venn.png">

## Joins example

- Some extra data is available in the suburb file such as council, region and distance
- If we need to do anlaysis on this level of granularity we need information from this data
- Let us first load the data using our good friend `read_csv`

```{r message=FALSE}
suburb_data <- read_csv("C:/Workspace/r-learning/data/processed/suburb_data.csv")

suburb_data
```

## Joins example

- If we want to find out the median property price by council 
- We have to join `melbourne_housing` to `suburb_data` 
- and then use what we have learnt with `group_by` and `summarise`

```{r}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  group_by(council_area) %>%
  summarise(median_property_price = median(price, na.rm = TRUE))
```

## Practice Question 1 

- Assuming real estate agents charge 2% of sold price as commission, can you give me the list of all agents and how much commission they made in the calendar year 2017 in descending order
- Hint: convert `dt` from charcter to date using `lubridate::dmy(dt)` and extract the year using `lubridate::year(dt)`. Also don't forget to use `na.rm = TRUE` in your summary function.
- Expected answer 

```{r echo=FALSE, warning=FALSE}
melbourne_housing %>%
  mutate(dt = lubridate::dmy(dt)) %>%
  mutate(yr = lubridate::year(dt)) %>%
  filter(yr == 2017) %>%
  group_by(selling_agent) %>%
  summarise(total_commission = 0.02 * sum(price, na.rm = TRUE)) %>%
  arrange(desc(total_commission))
```

## Practice Question 1 - Solution

```{r warning=FALSE}
melbourne_housing %>%
  mutate(dt = lubridate::dmy(dt)) %>%
  mutate(yr = lubridate::year(dt)) %>%
  filter(yr == 2017) %>%
  group_by(selling_agent) %>%
  summarise(total_commission = 0.02 * sum(price, na.rm = TRUE)) %>%
  arrange(desc(total_commission))
```

## Practice Question 2 

- What are the top 5 most expensive suburbs in descending order (by median house price) that are less than 10 km away from the city
- Hint: Join with `suburb_data` & use `distance_from_city` & use `row_number` or `dense_rank` to rank the suburbs
- Expected answer is 

```{r echo=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(distance_from_city < 10) %>%
  group_by(suburb) %>%
  summarise(median_house_price = median(price, na.rm = TRUE)) %>%
  mutate(rnk = row_number(desc(median_house_price))) %>%
  filter(rnk <= 5) %>%
  arrange(rnk)
```

## Practice Question 2 - Solution

```{r}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(distance_from_city < 10) %>%
  group_by(suburb) %>%
  summarise(median_house_price = median(price, na.rm = TRUE)) %>%
  mutate(rnk = row_number(desc(median_house_price))) %>%
  filter(rnk <= 5) %>%
  arrange(rnk)
```

## Practice Question 3

- I'd like a table of suburbs in the 10km to 20km from the city range, in the eastern metropolitan region, and I'd like to compare of what the median prices of properties are based on whether they have 2, 3, or 4 bedrooms
- Hint: Use `spread` after grouping to get one row for each suburb
- Expected Answer is

```{r echo=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(distance_from_city >= 10 & distance_from_city <=20) %>%
  filter(region_name == "Eastern Metropolitan") %>%
  filter(rooms %in% c(2,3,4)) %>%
  group_by(suburb, rooms) %>%
  summarise(median_price = median(price, na.rm = TRUE)) %>%
  spread(rooms, median_price)
```

## Practice Question 3 - Solution

```{r}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(distance_from_city >= 10 & distance_from_city <=20) %>%
  filter(region_name == "Eastern Metropolitan") %>%
  filter(rooms %in% c(2,3,4)) %>%
  group_by(suburb, rooms) %>%
  summarise(median_price = median(price, na.rm = TRUE)) %>%
  spread(rooms, median_price)
```

# Data Visualisation with ggplot2

## Introduction to plotting in R 

- Originally base R provided for simple plotting mechanisms 
- Just a simple call of `plot()` or `hist()` makes it easy to visualise data
- But it is not very flexible, nor is it consistent 

```{r}
options(scipen = 1000000)
docklands <- melbourne_housing %>%
  filter(suburb == "Docklands") %>%
  filter(!is.na(price))
plot(docklands$rooms, docklands$price)
```

## ggplot and grammar of graphics

- This is where `ggplot2` was written, as a way to define grammar of graphics
- A consistent structure to build a plot 
- One system, learn one time, reapply many times for different graphics
- Break down plotting into different layers
- Every ggplot consists of 3 major components
    * The data (For example the melbourne_housing data frame)
    * The geom (Say a scatter plot)
    * The aesthetic mappings (what the x axis should be, what the y axis should be)

## Our first ggplot

```{r warning=FALSE}
ggplot(docklands) + 
  geom_point(aes(x = rooms,
                 y = price))
```

## Adding colour 

- Lets say we want to distinguish houses, townhouses and units by different colours
```{r warning=FALSE}
ggplot(docklands) + 
  geom_point(aes(x = rooms, y = price, colour = type))
```

## Adding nice labels 

```{r}
ggplot(docklands) + 
  geom_point(aes(x = rooms, y = price, colour = type)) + 
  labs(x = "Rooms", y = "Price", title = "Docklands Properties")
```

## Other types of geoms

- Now that you've seen how easy it is to create ggplots, lets have a look at some other geoms commonly used 
- Histograms: To study the underlying distribution of a variable
- Boxplot: Alternative way to study distribution, but with median, IQR etc
- Bar plot: To study how categorical variables are represented 
- Line plot: To study trends of a variable

## Histograms

- Lets have a look at the distribution of property prices in the Melbourne council region
- We can create the data frame to send to the plot by first running the required `dplyr` code and then piping that into the `ggplot` function

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  ggplot() +
  geom_histogram(aes(x = price)) + 
  labs(x = "Price",
       y = "Number of properties")
```

## Histograms

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  ggplot() +
  geom_histogram(aes(x = price)) + 
  labs(x = "Price",
       y = "Number of properties")
```

## Boxplot

- Lets plot the same thing, but lets have a look at the distribution from a different angle
- Also lets split it up by the suburbs in the region to see if there's any difference

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  ggplot() +
  geom_boxplot(aes(x = suburb, y = price, fill = suburb)) + 
  labs(x = "Suburb",
       y = "Price",
       title = "Price distribution of Melbourne City Council")
```


## Boxplot

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  ggplot() +
  geom_boxplot(aes(x = suburb, y = price, fill = suburb)) + 
  labs(x = "Suburb",
       y = "Price",
       title = "Price distribution of Melbourne City Council")
```

## Bar Plot 

- Bar plots require your data to be in narrow form as opposed to wide form 
- Remember to use `spread` & `gather` as necessary if you need to convert the data
- Bar plots can be very intelligent and customisable, but today we will learn the most basic form `stat = "identity"`. This just means that the y axis value you supply should be used as it is, without any transformations

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  group_by(suburb) %>%
  summarise(number_of_properties = n()) %>%
  ggplot() +
  geom_bar(aes(x = suburb, y = number_of_properties, fill = suburb),
           stat = "identity") + 
  labs(x = "Suburb", y = "Number of Properties",
       title = "Properties sold in Melbourne City Council")
```

## Bar Plot 

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  group_by(suburb) %>%
  summarise(number_of_properties = n()) %>%
  ggplot() +
  geom_bar(aes(x = suburb, y = number_of_properties, fill = suburb),
           stat = "identity") + 
  labs(x = "Suburb", y = "Number of Properties",
       title = "Properties sold in Melbourne City Council")
```

## Line Plot

- Line plots are really useful if you want to track the flow of a metric along a number line
- Typically these are used to display time based trends 
- Structure very similar to bar plot but instead you use `geom_line`
- Different lines can be coloured but `ggplot` also requires each line to be its own `group`

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  mutate(dt = lubridate::dmy(dt)) %>%
  mutate(yr = lubridate::floor_date(dt, unit = "year")) %>%
  group_by(suburb, yr) %>%
  summarise(median_house_price = median(price, na.rm = TRUE)) %>%
  ggplot() +
  geom_line(aes(x = yr,
                y = median_house_price,
                group = suburb,
                colour = suburb)) +
  labs(x = "Year", y = "Median Price", title = "Price Trend")
```

## Line Plot 

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Melbourne City Council") %>%
  mutate(dt = lubridate::dmy(dt)) %>%
  mutate(yr = lubridate::floor_date(dt, unit = "year")) %>%
  group_by(suburb, yr) %>%
  summarise(median_house_price = median(price, na.rm = TRUE)) %>%
  ggplot() +
  geom_line(aes(x = yr,
                y = median_house_price,
                group = suburb,
                colour = suburb)) +
  labs(x = "Year", y = "Median Price", title = "Price Trend")
```

## Customising your ggplots

- Now that we know how to make basic charts in ggplot we can explore the power of customisation 
- How to change colours 
- Zooming out and in
- Manipulating shapes and sizes of scatter plot
- Transformation of scales
- Facets

## Colours 
- R gives you a bunch of default colour palettes to choose from
- This <a href = "https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf">cheatsheet</a> has lot of details but lets focus on the bottom left of the last page
- Lets build a simiar box plot to what we built earlier, but for Bayside City Council
- The only difference is, we have specified a `scale_fill_brewer`
- If we are changing the colour for a colour element it will be `scale_colour_brewer`

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  ggplot() +
  geom_boxplot(aes(x = suburb, y = price, fill = suburb)) + 
  labs(x = "Suburb",
       y = "Price",
       title = "Price distribution of Bayside City Council") +
  scale_fill_brewer(palette = "Paired")
```

## Colours

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  ggplot() +
  geom_boxplot(aes(x = suburb, y = price, fill = suburb)) + 
  labs(x = "Suburb",
       y = "Price",
       title = "Price distribution of Bayside City Council") +
  scale_fill_brewer(palette = "Paired")
```

## Zooming

- In the chart we just created, one super expensive house in Brighton really spoiled the scale for everything else
- While we were able to see that Cheltenham, Hampton East and Highett were clearly lower value suburbs than the others, we couldn't see subtle differences
- ggplot gives you a `coord_cartesian` function to let you zoom in on specific sections of your plot 

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  ggplot() +
  geom_boxplot(aes(x = suburb, y = price, fill = suburb)) + 
  labs(x = "Suburb",
       y = "Price",
       title = "Price distribution of Bayside City Council") +
  scale_fill_brewer(palette = "Paired") + 
  coord_cartesian(ylim = c(0, 3000000))
```

## Zooming 

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  ggplot() +
  geom_boxplot(aes(x = suburb, y = price, fill = suburb)) + 
  labs(x = "Suburb",
       y = "Price",
       title = "Price distribution of Bayside City Council") +
  scale_fill_brewer(palette = "Paired") + 
  coord_cartesian(ylim = c(0, 3000000))
```

## Shapes, sizes, alpha

- Lets build a scatter plot that visualises distance from city and median property price for 3 metro regions
- A simple scatter plot will look like this (we have learnt to colour, so we will add colour)

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(region_name %in% c("Southern Metropolitan",
                            "South-Eastern Metropolitan",
                            "Eastern Metropolitan")) %>%
  group_by(region_name, council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE)) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 colour = region_name)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") + 
  scale_color_manual(values = c("blue","red","green"))
```

## Shapes, sizes and alpha

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(region_name %in% c("Southern Metropolitan",
                            "South-Eastern Metropolitan",
                            "Eastern Metropolitan")) %>%
  group_by(region_name, council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE)) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 colour = region_name)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") + 
  scale_color_manual(values = c("blue","red","green"))
```

## Shapes

- Instead of distinguishing the region by colour, ggplot also allows you to distinguish by other options
- Lets try different shapes for our scatter plot points
- Simlar code, except instead of `colour` you will specify `shape`

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(region_name %in% c("Southern Metropolitan",
                            "South-Eastern Metropolitan",
                            "Eastern Metropolitan")) %>%
  group_by(region_name, council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE)) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 shape = region_name)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price")
```

## Shapes

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(region_name %in% c("Southern Metropolitan",
                            "South-Eastern Metropolitan",
                            "Eastern Metropolitan")) %>%
  group_by(region_name, council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE)) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 shape = region_name)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price")
```

## Shapes

- You can also have the shape and size be mapped to different variables
- Lets replicate the same chart but have colour mapped to region but shape mapped to council

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(region_name %in% c("Southern Metropolitan",
                            "South-Eastern Metropolitan",
                            "Eastern Metropolitan")) %>%
  group_by(region_name, council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE)) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 shape = council_area,
                 colour = region_name)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") +
  scale_colour_brewer(palette = "Dark2") + 
  scale_shape_manual(values = c(1:17))
```

## Shapes

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(region_name %in% c("Southern Metropolitan",
                            "South-Eastern Metropolitan",
                            "Eastern Metropolitan")) %>%
  group_by(region_name, council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE)) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 shape = council_area,
                 colour = region_name)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") +
  scale_colour_brewer(palette = "Dark2") + 
  scale_shape_manual(values = c(1:17))
```

## Sizes

- ggplot also allows you to customise the size of your points 
- Typically if you want to donate a third value in a chart to show proportion we can alter the size of the point according to a value
- Same example, but say we want to investigate whether a suburb like Brighton, does it just have a few high valued properties or does it score high on volume as well

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  group_by(council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE),
            number_of_sales = n()) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 colour = suburb,
                 size = number_of_sales)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") +
  scale_colour_brewer(palette = "Spectral")
```

## Sizes

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  group_by(council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE),
            number_of_sales = n()) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 colour = suburb,
                 size = number_of_sales)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") +
  scale_colour_brewer(palette = "Spectral")
```

## Alpha

- ggplot also allows you to customise the opacity of your points
- Can be used as an alternative to size
- Lets have a look at the same chart but with alpha instead of size
- alpha can be set as a value between 0 and 1 where 0.9 is closer to opaque and 0.1 is closer to transparent

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  group_by(council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE),
            number_of_sales = n()) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 colour = suburb,
                 size = 4,
                 alpha = number_of_sales)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") +
  scale_colour_brewer(palette = "Spectral")
```

## Alpha

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Bayside City Council") %>%
  group_by(council_area, suburb, distance_from_city) %>%
  summarise(median_property_price = median(price, na.rm = TRUE),
            number_of_sales = n()) %>%
  ggplot() + 
  geom_point(aes(x = distance_from_city,
                 y = median_property_price,
                 colour = suburb,
                 size = 4,
                 alpha = number_of_sales)) +
  labs(x = "Distance From City",
       y = "Median Property Price",
       tilte = "Relationship between distance and price") +
  scale_colour_brewer(palette = "Spectral")
```

## Facets

- Until now we have learnt how to change several aesthetics, use several geoms and create some great graphs
- Sometimes we may want to overlay different panels of graphs together showing something very similar 
- ggplot allows you to do this over facets
- Lets try and plot how property sales vary between houses, townhouses and units in the Monash City Council

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Monash City Council") %>%
  group_by(suburb, type) %>%
  summarise(median_property_value = median(price, na.rm = TRUE)) %>%
  ggplot() +
  geom_bar(aes(x = suburb, y = median_property_value, fill = suburb),
           stat = "identity") + 
  facet_wrap(~ type, nrow = 3, ncol = 1) + 
  labs(x = "Suburb", y = "Median Property Value")
```

## Facets

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Monash City Council") %>%
  group_by(suburb, type) %>%
  summarise(median_property_value = median(price, na.rm = TRUE)) %>%
  ggplot() +
  geom_bar(aes(x = suburb, y = median_property_value, fill = suburb),
           stat = "identity") + 
  facet_wrap(~ type, nrow = 3, ncol = 1) + 
  labs(x = "Suburb", y = "Median Property Value")
```

## Themes

- ggplot offers a lot of customisability on plot themes
- There are several inbuilt theme presets like `theme_minimal`, `theme_classic` etc 
- You can also create your own theme using the `theme` function if you want to 
- Replicating the same facet plot from the previous slide 

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Monash City Council") %>%
  group_by(suburb, type) %>%
  summarise(median_property_value = median(price, na.rm = TRUE)) %>%
  ggplot() +
  geom_bar(aes(x = suburb, y = median_property_value, fill = suburb),
           stat = "identity") + 
  facet_wrap(~ type, nrow = 3, ncol = 1) + 
  labs(x = "Suburb", y = "Median Property Value") + 
  theme_minimal()
```

## Themes

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=6, fig.width=8}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  filter(council_area == "Monash City Council") %>%
  group_by(suburb, type) %>%
  summarise(median_property_value = median(price, na.rm = TRUE)) %>%
  ggplot() +
  geom_bar(aes(x = suburb, y = median_property_value, fill = suburb),
           stat = "identity") + 
  facet_wrap(~ type, nrow = 3, ncol = 1) + 
  labs(x = "Suburb", y = "Median Property Value") + 
  theme_minimal()
```

## Practice Question 1 

- I'd like to plot a monthly trend line of how median property prices are tracking for each region 
- Hint: Use `lubridate::dmy(dt)` to convert `dt` to a date format and use `lubridate::floor_date(dt, unit = "month")` to extract the month 
- Hint: Use `geom_line()` with x axis as the month, y axis as median price, and group and colour as `region_name` from `suburb_data`
- Expected output is 

```{r echo=FALSE, fig.width=6, fig.height=3.5}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  mutate(dt = lubridate::dmy(dt)) %>%
  mutate(mth = lubridate::floor_date(dt, unit = "month")) %>%
  group_by(region_name, mth) %>%
  summarise(median_property_price = median(price, na.rm=TRUE)) %>%
  ggplot() + 
  geom_line(aes(x = mth, y = median_property_price,
                group = region_name, colour = region_name)) + 
  labs(x = "Month", y = "Median Property Price",
       tilte = "Region wise property prices")
```

## Practice Question 1 - Solution

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by = "suburb") %>%
  mutate(dt = lubridate::dmy(dt)) %>%
  mutate(mth = lubridate::floor_date(dt, unit = "month")) %>%
  group_by(region_name, mth) %>%
  summarise(median_property_price = median(price, na.rm=TRUE)) %>%
  ggplot() + 
  geom_line(aes(x = mth, y = median_property_price,
                group = region_name, colour = region_name)) + 
  labs(x = "Month", y = "Median Property Price",
       tilte = "Region wise property prices")
```

## Practice Question 2

- I'm looking at properties in Ringwood, Ringwood North and Ringwood East and I want to get an idea on the distribution of prices and visualise how much an extra room costs
- Hint: Use a boxplot to showcase the distribution and Use facets to compare at all 3 suburbs at once
- Hint: Convert rooms to character using `as.charcater(rooms)` otherwise ggplot thinks rooms is an integer continous variable
- Expected output is

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=6, fig.height=3.5}
melbourne_housing %>%
  filter(suburb %in% c("Ringwood", "Ringwood North", "Ringwood East")) %>%
  mutate(rooms = as.character(rooms)) %>%
  ggplot() + 
  geom_boxplot(aes(x = rooms, y = price, group =rooms, fill = rooms)) + 
  facet_wrap(~ suburb, nrow = 1, ncol = 3) + 
  labs(x = "Rooms", y = "Price")
```

## Practice Question 2 - Solution

```{r eval=FALSE}
melbourne_housing %>%
  filter(suburb %in% c("Ringwood", "Ringwood North", "Ringwood East")) %>%
  mutate(rooms = as.character(rooms)) %>%
  ggplot() + 
  geom_boxplot(aes(x = rooms, y = price, group = rooms, fill = rooms)) + 
  facet_wrap(~ suburb, nrow = 1, ncol = 3) + 
  labs(x = "Rooms", y = "Price")
```

## Practice Question 3

- I want to see what is the break up of property sales in the Port Phillip City Council by suburb, and I'm keen on knowing what percentage of all sales is units, townhouses and houses for each suburb
- Hint: Use `summarise` and `mutate` to create percentage of total metric
- Hint: Use `geom_bar` to create a stacked bar chart. Once you create your chart try adding `position = position_dodge()` to the `geom_bar` part of the code and see what changes
- Expected output is 

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=6, fig.height=3.5}
melbourne_housing %>%
  inner_join(suburb_data, by="suburb") %>%
  filter(council_area == "Port Phillip City Council") %>%
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  mutate(perc_of_total = number_of_properties/sum(number_of_properties)*100) %>%
  ggplot() + 
  geom_bar(aes(x = suburb, y = perc_of_total, fill = type),
           stat = "identity") + 
  labs(x = "Suburb", y = "% of properties")
```

## Practice Question 3 - Solution

```{r eval=FALSE}
melbourne_housing %>%
  inner_join(suburb_data, by="suburb") %>%
  filter(council_area == "Port Phillip City Council") %>%
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  mutate(perc_of_total = number_of_properties/sum(number_of_properties)*100) %>%
  ggplot() + 
  geom_bar(aes(x = suburb, y = perc_of_total, fill = type),
           stat = "identity") + 
  labs(x = "Suburb", y = "% of properties")
```

# Rmarkdown and related tools

## Why Rmarkdown?

- Rmarkdown is a system where you can put everything you learnt today together to produce reproducible anlaysis
- Rmarkdown lets you combine code, results, and commentary into one place
- Rmarkdown lets you use multiple languages (not just R but Python and SQL too) together
- Rmarkdown lets you create multiple output formats - PDFs, HTMLs, Word Docs, Powerpoint (yes this one is built in Rmarkdown!), books, dashboards, blogs, shiny applications etc
- Rmarkdown also lets you use the notebook feature - a popular data science tool 
- Built using markdown, which is the easiest language ever created 

## What we will learn today

- Creating simple Rmarkdown documents 
- Using Rmarkdown notebooks
- Flexdashboard 
- Very simple introduction to shiny

<p>
<img src = "https://d33wubrfki0l68.cloudfront.net/518c6867c530c6dee8722c9d8fa18df8af7f6cb1/71f4d/galleryimages/html.png"> <img src = "https://d33wubrfki0l68.cloudfront.net/dd978938797cada13cee7b3e2a88d7588a16ec1c/720af/galleryimages/dashboard2.png">
</p>

## Our very first Rmarkdown 

- First we must install the `rmarkdown` package
```{r eval=FALSE}
install.packages("rmarkdown")
```
- Now open a .Rmd document from File > New File > R Markdown and choose a title like `My First RMarkdown`
- You will find some example code in your newly opened file 
- There are 4 different sections 
    * YAML header
    * Code Chunks (in grey)
    * Headers after # 
    * Plain text
    
## YAML Header 

- The section right at the top between the `---` lines is called the YAML header
- In the YAML header we specify attributes about the document like 
    * Title
    * Author
    * Output style - Rmarkdown document, slides, dashboard etc 
    * Other features - default image size, themes etc 
- For our simple example lets just set the title and leave the output as a HTML document

<img src =https://d33wubrfki0l68.cloudfront.net/6c8488fd88918d3c1ccac03cb22b66c4cb011809/a9f2f/lesson-images/code-1-options.png>

## Code Chunks

- The section in the grey bit is called code chunks. You can have as many as you want.
- When you render (run) the Rmd file the code inside the chunk will be run and results will be embedded in the report
- Lets try an example where we play with our `melbourne_housing` dataset and the last ggplot we created, but instead of the plot lets just print the data frame
- Keep in mind that when you run a rmarkdown file, it is a new R session so we need the code for loading our data files. Insert this into your code chunk and hit the `knit` button
```{r eval=FALSE}
library(tidyverse)
library(lubridate)

melbourne_housing <- read_csv("C:/Workspace/r-learning/data/processed/melbourne_housing_market.csv")
suburb_data <- read_csv("C:/Workspace/r-learning/data/processed/suburb_data.csv")

melbourne_housing %>%
  inner_join(suburb_data, by="suburb") %>%
  filter(council_area == "Port Phillip City Council") %>%
  group_by(suburb, type) %>%
  summarise(number_of_properties = n()) %>%
  mutate(perc_of_total = number_of_properties/sum(number_of_properties)*100)
```

## Code Chunks

- For our second code chunk lets paste the 

# Thank You